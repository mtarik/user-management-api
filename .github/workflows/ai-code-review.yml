# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ Workflow de Revue de Code IA v3.0 - Standalone Version
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# âœ¨ FonctionnalitÃ©s v3.0 :
# - ğŸ“Š Scoring dÃ©taillÃ© par catÃ©gorie (/10 avec quality labels)
# - ğŸ”’ Analyse OWASP Top 10 2021 structurÃ©e
# - ğŸ—ï¸ Analyse architecturale approfondie (patterns, violations, couplage)
# - âš¡ Optimisations performance dÃ©taillÃ©es (N+1, caching, complexitÃ©)
# - ğŸ·ï¸ Auto-labelling automatique basÃ© sur l'analyse
# - ğŸš¨ SystÃ¨me de gates (fail-on-critical) pour bloquer les merges
# - ğŸ“ˆ Tracking des mÃ©triques et tendances
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: ğŸ¤– AI Code Review v3.0

on:
  # Se dÃ©clenche sur les Pull Requests
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - '**.java'

  # Se dÃ©clenche sur les commits sur ces branches
  push:
    branches:
      - main
      - develop
      - 'feature/**'
      - 'feat/**'
      - 'hotfix/**'
    paths:
      - '**.java'

  # Permet le dÃ©clenchement manuel
  workflow_dispatch:

jobs:
  ai-code-review:
    name: ğŸ“Š Revue de Code IA v3.0
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: â˜• Setup Java 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: ğŸ“¦ Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: ğŸ” Identifier les fichiers Java modifiÃ©s
        id: changed-files
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            git diff --name-only origin/${{ github.base_ref }}...${{ github.sha }} | grep '\.java$' > changed_files.txt || true
          else
            git diff --name-only HEAD~1 HEAD | grep '\.java$' > changed_files.txt || true
          fi

          if [ -s changed_files.txt ]; then
            echo "found=true" >> $GITHUB_OUTPUT
            echo "ğŸ“ Fichiers Java modifiÃ©s :"
            cat changed_files.txt
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Aucun fichier Java modifiÃ©"
          fi

      - name: â˜• Compilation du projet Java
        if: steps.changed-files.outputs.found == 'true'
        run: |
          if [ -f "pom.xml" ]; then
            echo "ğŸ”¨ Compilation avec Maven..."
            mvn clean compile -B -q || echo "âš ï¸ Avertissement: Erreur de compilation"
          elif [ -f "build.gradle" ]; then
            echo "ğŸ”¨ Compilation avec Gradle..."
            ./gradlew compileJava -q || echo "âš ï¸ Avertissement: Erreur de compilation"
          else
            echo "â„¹ï¸ Aucun systÃ¨me de build dÃ©tectÃ©"
          fi
        continue-on-error: true

      - name: ğŸ” Analyse statique (Checkstyle, PMD)
        if: steps.changed-files.outputs.found == 'true'
        run: |
          if [ -f "pom.xml" ]; then
            echo "ğŸ“‹ ExÃ©cution de Checkstyle..."
            mvn checkstyle:check || echo "âš ï¸ ProblÃ¨mes Checkstyle dÃ©tectÃ©s"
            echo "ğŸ” ExÃ©cution de PMD..."
            mvn pmd:check || echo "âš ï¸ ProblÃ¨mes PMD dÃ©tectÃ©s"
          fi
        continue-on-error: true

      - name: ğŸ Setup Python
        if: steps.changed-files.outputs.found == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: ğŸ“¥ Checkout AI Code Review Agent
        if: steps.changed-files.outputs.found == 'true'
        uses: actions/checkout@v4
        with:
          repository: mtarik/java-ai-code-review
          path: .ai-review-agent
          token: ${{ secrets.PAT_GITHUB_TOKEN }}

      - name: ğŸ“¦ Copier les scripts de l'agent
        if: steps.changed-files.outputs.found == 'true'
        run: |
          echo "ğŸ“¦ Configuration de l'agent AI Code Review v3.0..."
          mkdir -p scripts/ai_reviewer/providers

          # Copier tous les fichiers depuis le repo clonÃ©
          cp .ai-review-agent/scripts/ai_code_reviewer.py scripts/
          cp .ai-review-agent/scripts/requirements.txt scripts/
          cp -r .ai-review-agent/scripts/ai_reviewer/* scripts/ai_reviewer/

          echo "âœ… Agent configurÃ© avec succÃ¨s"
          echo "ğŸ“ Fichiers copiÃ©s :"
          ls -la scripts/ai_reviewer/providers/

      - name: ğŸ“¦ Installer les dÃ©pendances Python
        if: steps.changed-files.outputs.found == 'true'
        run: |
          pip install -r scripts/requirements.txt

      - name: ğŸ¤– Analyse IA avec Claude Sonnet 4.5
        if: steps.changed-files.outputs.found == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_NAME: ${{ github.repository }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          echo "ğŸ§  Lancement de l'analyse IA v3.0..."
          python scripts/ai_code_reviewer.py

      - name: ğŸ“Š Upload du rapport d'analyse
        if: always() && steps.changed-files.outputs.found == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ai-review-report-${{ github.sha }}
          path: |
            code_review_*.md
            code_review_*.json
            review_report.json
            review_report.md
            metrics_report.md
          retention-days: 30

      - name: ğŸ’¬ Poster les commentaires inline sur Files Changed
        if: github.event_name == 'pull_request' && steps.changed-files.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // Trouver le fichier JSON de revue
            const files = fs.readdirSync('.');
            const jsonFile = files.find(f => f.startsWith('code_review_') && f.endsWith('.json'));

            if (!jsonFile) {
              console.log('âš ï¸ Aucun rapport JSON trouvÃ©');
              return;
            }

            const review = JSON.parse(fs.readFileSync(jsonFile, 'utf8'));

            // PrÃ©parer les commentaires inline
            const reviewComments = [];
            let summaryBody = '## ğŸ¤– Revue de Code IA v3.0 - RÃ©sultats\n\n';

            // Construire un rÃ©sumÃ©
            const totalIssues = review.files?.reduce((sum, file) => sum + (file.issues?.length || 0), 0) || 0;
            summaryBody += `ğŸ“Š **Score Global**: ${review.overall_score || 0}/10\n`;
            summaryBody += `ğŸ” **ProblÃ¨mes dÃ©tectÃ©s**: ${totalIssues}\n\n`;

            // CatÃ©goriser les problÃ¨mes
            const criticalCount = review.files?.reduce((sum, file) =>
              sum + (file.issues?.filter(i => i.severity === 'critical').length || 0), 0) || 0;
            const securityCount = review.files?.reduce((sum, file) =>
              sum + (file.issues?.filter(i => i.category?.toLowerCase().includes('security')).length || 0), 0) || 0;

            if (criticalCount > 0) summaryBody += `ğŸ”´ **Critiques**: ${criticalCount}\n`;
            if (securityCount > 0) summaryBody += `ğŸ”’ **SÃ©curitÃ©**: ${securityCount}\n`;

            // Parcourir les fichiers et crÃ©er des commentaires inline
            review.files?.forEach(file => {
              file.issues?.forEach(issue => {
                // DÃ©terminer l'icÃ´ne selon la sÃ©vÃ©ritÃ©
                let icon = 'ğŸ’¡';
                if (issue.severity === 'critical') icon = 'ğŸ”´';
                else if (issue.severity === 'high') icon = 'ğŸŸ ';
                else if (issue.severity === 'medium') icon = 'ğŸŸ¡';

                // Construire le corps du commentaire
                let commentBody = `${icon} **${issue.category || 'Issue'}** (${issue.severity || 'info'})\n\n`;
                commentBody += `${issue.description}\n\n`;

                if (issue.owasp_category) {
                  commentBody += `ğŸ›¡ï¸ **OWASP**: ${issue.owasp_category}\n\n`;
                }

                if (issue.suggestion) {
                  commentBody += `ğŸ’¡ **Suggestion**:\n${issue.suggestion}\n\n`;
                }

                if (issue.code_snippet) {
                  commentBody += `\`\`\`java\n${issue.code_snippet}\n\`\`\`\n\n`;
                }

                commentBody += `---\nğŸ¤– *DÃ©tectÃ© par Claude Sonnet 4.5 - AI Code Review v3.0*`;

                // Ajouter le commentaire inline
                reviewComments.push({
                  path: file.file_path,
                  line: issue.line_number || 1,
                  body: commentBody
                });
              });
            });

            summaryBody += '\n---\n';
            summaryBody += `ğŸ” Commit: \`${context.sha.substring(0, 7)}\`\n`;
            summaryBody += `â° AnalysÃ© le: ${new Date().toLocaleString('fr-FR')}\n`;
            summaryBody += `\nğŸ“ **${reviewComments.length} commentaires inline** ont Ã©tÃ© ajoutÃ©s sur les fichiers modifiÃ©s.\n\n`;
            summaryBody += `ğŸ¤– PropulsÃ© par Claude Sonnet 4.5`;

            console.log(`ğŸ“ CrÃ©ation d'une review avec ${reviewComments.length} commentaires inline...`);

            // CrÃ©er une review avec des commentaires inline
            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                event: 'COMMENT',
                body: summaryBody,
                comments: reviewComments
              });
              console.log(`âœ… Review crÃ©Ã©e avec succÃ¨s !`);
            } catch (error) {
              console.log(`âš ï¸ Erreur lors de la crÃ©ation de la review: ${error.message}`);
              // Fallback: poster un commentaire gÃ©nÃ©ral si la review Ã©choue
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: summaryBody + '\n\nâš ï¸ Note: Impossible de poster les commentaires inline. Consultez les artefacts pour le rapport complet.'
              });
            }

      - name: ğŸ·ï¸ Auto-labelling de la PR
        if: github.event_name == 'pull_request' && steps.changed-files.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // Trouver le fichier JSON de revue
            const files = fs.readdirSync('.');
            const jsonFile = files.find(f => f.startsWith('code_review_') && f.endsWith('.json'));

            if (!jsonFile) {
              console.log('âš ï¸ Aucun rapport JSON trouvÃ© pour l\'auto-labelling');
              return;
            }

            const review = JSON.parse(fs.readFileSync(jsonFile, 'utf8'));
            const labels = new Set();

            // Analyser les issues pour dÃ©terminer les labels
            let criticalCount = 0;
            let securityCount = 0;
            let performanceCount = 0;
            let architectureCount = 0;

            review.files?.forEach(file => {
              file.issues?.forEach(issue => {
                if (issue.severity === 'critical') {
                  criticalCount++;
                  labels.add('ai-review:critical');
                }

                const category = issue.category?.toLowerCase() || '';
                if (category.includes('security') || category.includes('sÃ©curitÃ©')) {
                  securityCount++;
                  labels.add('ai-review:security');
                } else if (category.includes('performance')) {
                  performanceCount++;
                  labels.add('ai-review:performance');
                } else if (category.includes('architecture')) {
                  architectureCount++;
                  labels.add('ai-review:architecture');
                }

                // Labels OWASP si applicable
                if (issue.owasp_category) {
                  labels.add('ai-review:owasp');
                }
              });
            });

            // Ajouter un label de score basÃ© sur overall_score (0-10)
            const score = review.overall_score || 0;
            if (score >= 9) {
              labels.add('ai-review:excellent');
            } else if (score >= 7) {
              labels.add('ai-review:good');
            } else if (score >= 5) {
              labels.add('ai-review:acceptable');
            } else {
              labels.add('ai-review:needs-work');
            }

            // Label de qualitÃ©
            if (review.quality_label) {
              labels.add(`quality:${review.quality_label.toLowerCase().replace(/\s+/g, '-')}`);
            }

            // âœ¨ NOUVEAUX LABELS MÃ‰TRIQUES DÃ‰TAILLÃ‰S

            // Label de score exact
            labels.add(`score: ${Math.round(score)}/10`);

            // Labels de compteurs d'issues
            const totalIssues = review.files?.reduce((sum, file) => sum + (file.issues?.length || 0), 0) || 0;
            if (totalIssues > 0) {
              labels.add(`issues: ${totalIssues}`);
            }

            // Labels de sÃ©vÃ©ritÃ© avec compteurs
            if (criticalCount > 0) labels.add(`critical: ${criticalCount}`);

            const highCount = review.files?.reduce((sum, file) =>
              sum + (file.issues?.filter(i => i.severity === 'high').length || 0), 0) || 0;
            if (highCount > 0) labels.add(`high: ${highCount}`);

            const mediumCount = review.files?.reduce((sum, file) =>
              sum + (file.issues?.filter(i => i.severity === 'medium').length || 0), 0) || 0;
            if (mediumCount > 0) labels.add(`medium: ${mediumCount}`);

            // Labels de catÃ©gories avec compteurs
            if (securityCount > 0) labels.add(`security: ${securityCount}`);
            if (performanceCount > 0) labels.add(`performance: ${performanceCount}`);
            if (architectureCount > 0) labels.add(`architecture: ${architectureCount}`);

            // Compter les issues OWASP
            const owaspCount = review.files?.reduce((sum, file) =>
              sum + (file.issues?.filter(i => i.owasp_category).length || 0), 0) || 0;
            if (owaspCount > 0) labels.add(`owasp: ${owaspCount}`);

            // Labels de score par catÃ©gorie (si disponibles)
            if (review.scores) {
              if (review.scores.security !== undefined) {
                labels.add(`security-score: ${Math.round(review.scores.security)}/10`);
              }
              if (review.scores.performance !== undefined) {
                labels.add(`performance-score: ${Math.round(review.scores.performance)}/10`);
              }
              if (review.scores.architecture !== undefined) {
                labels.add(`architecture-score: ${Math.round(review.scores.architecture)}/10`);
              }
              if (review.scores.code_quality !== undefined) {
                labels.add(`quality-score: ${Math.round(review.scores.code_quality)}/10`);
              }
            }

            console.log(`ğŸ“Š Analyse: ${criticalCount} critiques, ${securityCount} sÃ©curitÃ©, ${performanceCount} performance, ${architectureCount} architecture`);
            console.log(`ğŸ·ï¸ Labels Ã  ajouter: ${Array.from(labels).join(', ')}`);

            // DÃ©finir les couleurs des labels
            const labelColors = {
              'ai-review:critical': 'b60205',
              'ai-review:security': 'd93f0b',
              'ai-review:owasp': 'c5def5',
              'ai-review:performance': 'fbca04',
              'ai-review:architecture': '0e8a16',
              'ai-review:excellent': '0e8a16',
              'ai-review:good': 'a2eeef',
              'ai-review:acceptable': 'fbca04',
              'ai-review:needs-work': 'd93f0b',
              'quality:excellent-code-review': '0e8a16',
              'quality:good-code-review': 'a2eeef',
              'quality:acceptable-code-review': 'fbca04',
              'quality:needs-work': 'd93f0b',
              // Couleurs pour les labels mÃ©triques
              'score: 0/10': 'b60205',
              'score: 1/10': 'b60205',
              'score: 2/10': 'd93f0b',
              'score: 3/10': 'd93f0b',
              'score: 4/10': 'e99695',
              'score: 5/10': 'fbca04',
              'score: 6/10': 'fbca04',
              'score: 7/10': 'bfe5bf',
              'score: 8/10': '5cb85c',
              'score: 9/10': '0e8a16',
              'score: 10/10': '0e8a16'
            };

            const labelDescriptions = {
              'ai-review:critical': 'ProblÃ¨mes critiques dÃ©tectÃ©s par IA',
              'ai-review:security': 'ProblÃ¨mes de sÃ©curitÃ© dÃ©tectÃ©s',
              'ai-review:owasp': 'VulnÃ©rabilitÃ©s OWASP Top 10',
              'ai-review:performance': 'Optimisations de performance suggÃ©rÃ©es',
              'ai-review:architecture': 'ProblÃ¨mes architecturaux',
              'ai-review:excellent': 'Score IA excellent (9-10/10)',
              'ai-review:good': 'Bon score IA (7-8/10)',
              'ai-review:acceptable': 'Score IA acceptable (5-6/10)',
              'ai-review:needs-work': 'NÃ©cessite du travail (0-4/10)',
              'quality:excellent-code-review': 'QualitÃ© excellente',
              'quality:good-code-review': 'Bonne qualitÃ©',
              'quality:acceptable-code-review': 'QualitÃ© acceptable',
              'quality:needs-work': 'QualitÃ© Ã  amÃ©liorer'
            };

            // Ajouter des descriptions pour les labels mÃ©triques
            labels.forEach(label => {
              if (label.startsWith('score:') && !labelDescriptions[label]) {
                labelDescriptions[label] = 'Score global de la revue IA';
              } else if (label.startsWith('issues:')) {
                labelDescriptions[label] = 'Nombre total de problÃ¨mes dÃ©tectÃ©s';
              } else if (label.startsWith('critical:')) {
                labelDescriptions[label] = 'Nombre de problÃ¨mes critiques';
              } else if (label.startsWith('high:')) {
                labelDescriptions[label] = 'Nombre de problÃ¨mes haute prioritÃ©';
              } else if (label.startsWith('medium:')) {
                labelDescriptions[label] = 'Nombre de problÃ¨mes moyenne prioritÃ©';
              } else if (label.startsWith('security:') && !label.includes('score')) {
                labelDescriptions[label] = 'Nombre de problÃ¨mes de sÃ©curitÃ©';
              } else if (label.startsWith('performance:') && !label.includes('score')) {
                labelDescriptions[label] = 'Nombre de problÃ¨mes de performance';
              } else if (label.startsWith('architecture:') && !label.includes('score')) {
                labelDescriptions[label] = 'Nombre de problÃ¨mes architecturaux';
              } else if (label.startsWith('owasp:')) {
                labelDescriptions[label] = 'Nombre de vulnÃ©rabilitÃ©s OWASP';
              } else if (label.includes('-score:')) {
                labelDescriptions[label] = `Score ${label.split('-')[0]} dÃ©taillÃ©`;
              }
            });

            // RÃ©cupÃ©rer les labels existants du repo
            let existingLabels = [];
            try {
              const response = await github.rest.issues.listLabelsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              existingLabels = response.data.map(l => l.name);
            } catch (error) {
              console.log('âš ï¸ Erreur lors de la rÃ©cupÃ©ration des labels:', error.message);
            }

            // CrÃ©er les labels manquants
            for (const label of labels) {
              if (!existingLabels.includes(label)) {
                try {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: labelColors[label] || 'ededed',
                    description: labelDescriptions[label] || 'Auto-gÃ©nÃ©rÃ© par AI Code Review'
                  });
                  console.log(`âœ… Label crÃ©Ã©: ${label}`);
                } catch (error) {
                  if (error.status !== 422) {
                    console.log(`âš ï¸ Impossible de crÃ©er le label ${label}:`, error.message);
                  }
                }
              }
            }

            // Appliquer les labels Ã  la PR
            if (labels.size > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: Array.from(labels)
                });
                console.log(`âœ… ${labels.size} label(s) ajoutÃ©(s) Ã  la PR`);
              } catch (error) {
                console.log('âš ï¸ Erreur lors de l\'ajout des labels:', error.message);
              }
            } else {
              console.log('â„¹ï¸ Aucun label Ã  ajouter');
            }

      - name: âœ… RÃ©sumÃ© de l'analyse
        if: always()
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“Š RÃ‰SUMÃ‰ DE L'ANALYSE IA v3.0"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          if [ "${{ steps.changed-files.outputs.found }}" == "true" ]; then
            if ls code_review_*.json 1> /dev/null 2>&1; then
              echo "âœ… Revue de code terminÃ©e avec succÃ¨s"
              echo "ğŸ“ Rapport disponible dans les artefacts"
            else
              echo "âš ï¸ Aucun rapport gÃ©nÃ©rÃ©"
            fi
          else
            echo "â„¹ï¸ Aucun fichier Java Ã  analyser"
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
